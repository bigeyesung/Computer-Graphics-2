The complete order of my thinking is “creating objects”->”glutDisplayFunc(Render)”—>”Render”->”CastRay”->”CheckIntersection(ray,info)”->”Insersect(ray,info) in Object.cpp”->”implementing lighting in CastRay”->”implementing shadows in CastRay”->”implementing reflections in CastRay”->’’Render”-”glutDisplayFunc(Render)”, and I will explain each function with this order.

At the beginning,  it should be discussed the intersections of rays and objects in space. There are three possible intersections for spheres, and if discriminant check is greater than zero, which means two points of intersection and we retrieve the point which is closer to the camera, and if discriminant check is zero which means only one intersection point, and if discriminant check is less than zero which means no intersections. In terms of planes, it needs to judge whether the normal vector of a plane is perpendicular to the ray direction or not and if they are perpendicular to each other which mean they have no intersection points otherwise they have one intersection point. In terms of triangles, it is similar to the judgement of planes, if the normal vector of a triangle is perpendicular to ray direction which means they have no intersections; however, the difference in triangles is it needs to judge three vertices,and we need to know outer product of hit point to each vertex, and compare to the normal vector if the inner product of they is negative which means hit point is on the wrong side otherwise it is on the right side. After being checked for each objects, it is also needed to be updated intersection information which includes hit point, hit normal, hit time, hit material.

 Then in the main function of RayTracer.cpp, “glutDisplayFunc(Render)” is the code which display the objects and if tracing the parameter it will be traced to the Render function. In Render function, it will set each pixel a color, if CastRay(ray,payload) > 0 it will render the pixel a selected color from payload.color otherwise it will set no color, then if we move to the CastRay function it is the most important function because it should implement light function, reflection function, and shadow function.Before we implement above effects we need to check objects intersections first. Therefore tracing to CheckIntersection(ray,info) which is functioning to judge whether the ray intersects with each object or not, so it needs discriminant checks for different objects, which is discussed in the second paragraph. Furthermore, we need to judge which object is the nearest one to the ray origin, and in order to do so we set a variable to store info.time of each object and sort the info.time to retrieve to minimal info.time as the nearest object and sent back to CastRay. 

In the light function, the main formula is “I_color= I_diffuse+I_ambient+I_specular”. We need to refer the properties of the material of the objects, and setting a diffuse and specular reflectivity in the red, green and blue channels. For red color we need to set such as I_red=L_r*kd*cosTheta+L_r*ks*cosAlpha^n where L_r is the intensity of the light, kd is the diffuse reflectivity, and ks is the specular reflectivity in the red channel, and recursive the same codes in green  and blue channels, and the final output should be (I_red,I_green,I_blue).

In the shadow function, the function of this is similar to that of CheckIntersection, and the same thing is that we set a variable to store nearsest objects, and set the info.hit point to the nearest objects and then trace the ray to the light origin, if trace() is false which means there are other objects block the tracing light which means it will have shadows in front between the objects, so we set a darker light as a shadow on the bottom of the object.

In the reflective function, the reflection ray can be called reflection or specular ray, and the process is recursive, which means the process will keep casting rays unless the ray doesn’t intersect at all(in this case we return background color), and in order to do so, we beed to set a limit on the number of recursions which is ray depth, and we stop further executions if we reach the limit and return the background color. 
After the above effects are finished, we set a final color which includes light function, shadow function, and reflection function and assign it to the payload.color, and then we back to Render function to implement rendering colors and then return to the main function to complete other codes.
